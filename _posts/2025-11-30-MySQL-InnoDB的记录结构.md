---
title: MySQL - InnoDB的记录结构
description: 
author: zhang
date: 2025-11-30 11:33:00 +0800
categories: [MySQL, MySQL是怎样运行的 - 笔记]
tags: [MySQL, Reading Notes]
pin: false
math: true
mermaid: true
---

## InnoDB页简介

`InnoDB`是一个将表中的数据存储到磁盘上的存储引擎。真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中。InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，**InnoDB中页的大小一般为 16 KB**。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

## InnoDB行格式

InnoDB存储引擎设计了4种不同类型的行格式，分别是`Compact`、`Redundant`、`Dynamic`和`Compressed`。

### 指定行格式的语法

```
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

### Compact行格式

![3](/assets/images/3.png)

一条完整的记录其实可以被分为**记录的额外信息**和**记录的真实数据**两大部分。

#### 记录的额外信息

信息分为3类，分别是**变长字段长度列表**、**NULL值列表**和**记录头信息**。

##### 变长字段长度列表

MySQL支持一些变长的数据类型，比如`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型。用这些类型并且当实际存储不是`NULL`时，会在头部存储当前实际数据的长度。（实际上某个列是否需要存`变长字段长度列表`，和是否是变长类型，是否是变长字符集相关）。
存储的顺序和列的顺序相反。
例如：

```
【 06 02 03 | NULL值列表 | 记录头信息 】【'abc', 'ab', NULL, 'cdsewq'】
```

这个例子里，每一个列的长度用一个字节（2位十六进制）表示就够。但是InnoDB在这个方面有自己的规则：
我们首先声明一下W、M和L的意思：

1. 假设某个字符集中表示一个字符最多需要使用的字节数为W，比方说utf8字符集中的W就是3，gbk字符集中的W就是2，ascii字符集中的W就是1。
2. 对于变长类型VARCHAR(M)来说，这种类型表示能存储最多M个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是M×W。
3. 假设它实际存储的字符串占用的字节数是L。

规则是：
1. 如果**M×W <= 255**（字节），那么使用1个字节来表示真正字符串占用的字节数。
2. 如果**M×W > 255**（字节），则分为两种情况：
    1.1 如果**L <= 127**（字节），则用1个字节来表示真正字符串占用的字节数。
    1.2 如果**L > 127**（字节），则用2个字节来表示真正字符串占用的字节数。

*表中所有的列都不是变长的数据类型的话，这一部分就不需要有。*

##### NULL值列表

某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以`Compact`行格式把这些值为NULL的列统一管理起来，存储到NULL值列表中。规则和处理过程：
1. 只统计可以放 NULL 的列，排除例如：主键，`Not Null`修饰的列。如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了。
2. 在二进制位中逆序表示：
- 二进制位的值为1时，代表该列的值为NULL。
- 二进制位的值为0时，代表该列的值不为NULL。
3. MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。


举例：
1. 第c1和c3是不能为NULL，【c1='abc', c2=NULL, c3='dd', c4=NULL】这个行的结构是：
```
【 02 03 | [00000011] | 记录头信息 】【'abc', 'dd'】
```

2. 第c2和c4不能为NULL，【c1='abc', c2='cbad', c3=NULL, c4='d'】这个行的结构是：
```
【 01 04 03 | [00000010] | 记录头信息】【'abc', 'cbad', 'd'】
```

##### 记录头信息（了解）

![4.png](/assets/images/4.png)


| 名称           | 大小（单位：bit） | 描述                                          |
| ------------ | ---------- | ------------------------------------------- |
| 预留位1         | 1          | 没有使用                                        |
| 预留位2         | 1          | 没有使用                                        |
| delete_mask  | 1          | 标记该记录是否被删除                                  |
| min_rec_mask | 1          | B+树的每层非叶子节点中的最小记录会添加该标记                     |
| n_owned      | 4          | 表示当前记录拥有的记录数                                |
| heap_no      | 13         | 表示当前记录在记录堆的位置信息                             |
| record_type  | 3          | 表示当前记录的类型，0=普通记录，1=B+树非叶子节点记录，2=最小记录，3=最大记录 |
| next_record  | 16         | 表示下一条记录的相对位置                                |

#### 记录的真实数据

在这部分除了记录每一列非null的值，还有其他几个隐藏列。

| 列名          | 是否必须  | 占用空间 | 描述                 |
|--------------|--------- | ------- | ------------------- |
| `DB_ROW_ID`  | 否       | 6字节    | 行ID，唯一标识一条记录 |
| `DB_TRX_ID`  | 是       | 6字节    | 事务ID               |
| `DB_ROLL_PTR`| 是       | 7字节    | 回滚指针              |

InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键, 如果没有，则选取一个Unique键作为主键。再没有的话，就添加DB_ROW_ID这列作为主键，否则就不添加。


#### CHAR(M)列的存储格式

如果CHAR(M)的列字符集是固定长度字符集，如`ascii`，那么`变长字段长度列表`里不会记录。
如果是非固定长度字符集，如`utf8`, 那么`变长字段长度列表`里会记录该列的实际字节长度。

### 行溢出数据

#### VARCHAR(M)最多能存储的数据

**`MySQL`对一条记录占用的最大存储空间是有限制的，除了`BLOB`或者`TEXT`类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过`65535`个字节。**

我们为了存储一个`VARCHAR(M)`类型的列，其实需要占用3部分存储空间：

- 真实数据
- 真实数据占用字节的长度
- NULL值标识，如果该列有`NOT NULL`属性则可以没有这部分存储空间

所以如果该`VARCHAR`类型的列没有`NOT NULL`属性，那最多只能存储`65532`个字节的数据。

M的最大取值取决于该字符集表示一个字符最多需要的字节数。
所以如果字符集是`ascii`的话，那么M最多可以是`65532（字符）`。
如果是其他字符集，例如`utf8`, 他是`变长字符集`，每个字符`1-3`字节。那么M最多就是`65532/3`(字符)。

#### 记录中的数据太多产生的溢出

`InnoDB` 是以页来管理数据的，一个页是`16KB`， 也就是`16384字节`。而我们的行记录是分配到某个页中的，
但是从上面的结论里得到VARCHAR最多能存储`65532字节`，这样就会导致行的大小超过页的大小。所以在`Compact`行格式下，对于占用非常大的列，在`记录真实数据`的部分只记录前`768字节`，其他数据分配到其他页，`768字节`的后面还会有其他`20字节`用来存储指向这些页的地址以及在其他页中所占用的字节数。

最后需要注意的是，不只是 `VARCHAR(M)` 类型的列，其他的 `TEXT`、`BLOB` 类型的列在存储数据非常多的时候也会发生行溢出。

![5.png](/assets/images/5.png)

#### 行溢出的临界点

